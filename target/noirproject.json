{"noir_version":"1.0.0-beta.0+7311d8ca566c3b3e0744389fc5e4163741927767","hash":12192948249362239352,"abi":{"parameters":[{"name":"fighter","type":{"kind":"struct","path":"Person","fields":[{"name":"age","type":{"kind":"field"}}]},"visibility":"private"},{"name":"password","type":{"kind":"array","length":2,"type":{"kind":"field"}},"visibility":"private"},{"name":"passwordHash","type":{"kind":"field"},"visibility":"public"}],"return_type":null,"error_types":{}},"bytecode":"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","debug_symbols":"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","file_map":{"25":{"source":"pub mod bn254;\nuse crate::runtime::is_unconstrained;\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        assert(BIT_SIZE < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_le_bits\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_be_bits\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n","path":"std/field/mod.nr"},"29":{"source":"// Instantiations of Poseidon permutation for the prime field of the same order as BN254\nuse crate::hash::poseidon::bn254::consts;\nuse crate::hash::poseidon::permute;\n\n#[field(bn254)]\npub fn x5_2(mut state: [Field; 2]) -> [Field; 2] {\n    state = permute(consts::x5_2_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_3(mut state: [Field; 3]) -> [Field; 3] {\n    state = permute(consts::x5_3_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_4(mut state: [Field; 4]) -> [Field; 4] {\n    state = permute(consts::x5_4_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_5(mut state: [Field; 5]) -> [Field; 5] {\n    state = permute(consts::x5_5_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_6(mut state: [Field; 6]) -> [Field; 6] {\n    state = permute(consts::x5_6_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_7(mut state: [Field; 7]) -> [Field; 7] {\n    state = permute(consts::x5_7_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_8(mut state: [Field; 8]) -> [Field; 8] {\n    state = permute(consts::x5_8_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_9(mut state: [Field; 9]) -> [Field; 9] {\n    state = permute(consts::x5_9_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_10(mut state: [Field; 10]) -> [Field; 10] {\n    state = permute(consts::x5_10_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_11(mut state: [Field; 11]) -> [Field; 11] {\n    state = permute(consts::x5_11_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_12(mut state: [Field; 12]) -> [Field; 12] {\n    state = permute(consts::x5_12_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_13(mut state: [Field; 13]) -> [Field; 13] {\n    state = permute(consts::x5_13_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_14(mut state: [Field; 14]) -> [Field; 14] {\n    state = permute(consts::x5_14_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_15(mut state: [Field; 15]) -> [Field; 15] {\n    state = permute(consts::x5_15_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_16(mut state: [Field; 16]) -> [Field; 16] {\n    state = permute(consts::x5_16_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_17(mut state: [Field; 17]) -> [Field; 17] {\n    state = permute(consts::x5_17_config(), state);\n\n    state\n}\n","path":"std/hash/poseidon/bn254/perm.nr"},"30":{"source":"// Instantiations of Poseidon constants, permutations and sponge for prime field of the same order as BN254\npub mod perm;\npub mod consts;\n\nuse crate::hash::poseidon::absorb;\n\n// Variable-length Poseidon-128 sponge as suggested in second bullet point of section 3 of https://eprint.iacr.org/2019/458.pdf\n#[field(bn254)]\npub fn sponge<let N: u32>(msg: [Field; N]) -> Field {\n    absorb(consts::x5_5_config(), [0; 5], 4, 1, msg)[1]\n}\n\n// Various instances of the Poseidon hash function\n// Consistent with Circom's implementation\n#[no_predicates]\npub fn hash_1(input: [Field; 1]) -> Field {\n    let mut state = [0; 2];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_2(state)[0]\n}\n\n#[no_predicates]\npub fn hash_2(input: [Field; 2]) -> Field {\n    let mut state = [0; 3];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_3(state)[0]\n}\n\n#[no_predicates]\npub fn hash_3(input: [Field; 3]) -> Field {\n    let mut state = [0; 4];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_4(state)[0]\n}\n\n#[no_predicates]\npub fn hash_4(input: [Field; 4]) -> Field {\n    let mut state = [0; 5];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_5(state)[0]\n}\n\n#[no_predicates]\npub fn hash_5(input: [Field; 5]) -> Field {\n    let mut state = [0; 6];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_6(state)[0]\n}\n\n#[no_predicates]\npub fn hash_6(input: [Field; 6]) -> Field {\n    let mut state = [0; 7];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_7(state)[0]\n}\n\n#[no_predicates]\npub fn hash_7(input: [Field; 7]) -> Field {\n    let mut state = [0; 8];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_8(state)[0]\n}\n\n#[no_predicates]\npub fn hash_8(input: [Field; 8]) -> Field {\n    let mut state = [0; 9];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_9(state)[0]\n}\n\n#[no_predicates]\npub fn hash_9(input: [Field; 9]) -> Field {\n    let mut state = [0; 10];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_10(state)[0]\n}\n\n#[no_predicates]\npub fn hash_10(input: [Field; 10]) -> Field {\n    let mut state = [0; 11];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_11(state)[0]\n}\n\n#[no_predicates]\npub fn hash_11(input: [Field; 11]) -> Field {\n    let mut state = [0; 12];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_12(state)[0]\n}\n\n#[no_predicates]\npub fn hash_12(input: [Field; 12]) -> Field {\n    let mut state = [0; 13];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_13(state)[0]\n}\n\n#[no_predicates]\npub fn hash_13(input: [Field; 13]) -> Field {\n    let mut state = [0; 14];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_14(state)[0]\n}\n\n#[no_predicates]\npub fn hash_14(input: [Field; 14]) -> Field {\n    let mut state = [0; 15];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_15(state)[0]\n}\n\n#[no_predicates]\npub fn hash_15(input: [Field; 15]) -> Field {\n    let mut state = [0; 16];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_16(state)[0]\n}\n\n#[no_predicates]\npub fn hash_16(input: [Field; 16]) -> Field {\n    let mut state = [0; 17];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_17(state)[0]\n}\n","path":"std/hash/poseidon/bn254.nr"},"31":{"source":"pub mod bn254; // Instantiations of Poseidon for prime field of the same order as BN254\nuse crate::default::Default;\nuse crate::hash::Hasher;\n\n// A config struct defining the parameters of the Poseidon instance to use.\n//\n// A thorough writeup of this method (along with an unoptimized method) can be found at: https://spec.filecoin.io/algorithms/crypto/poseidon/\npub struct PoseidonConfig<let T: u32, let N: u32, let X: u32> {\n    // State width, should be equal to `T`\n    t: Field,\n    // Number of full rounds. should be even\n    rf: u8,\n    // Number of partial rounds\n    rp: u8,\n    // S-box power; depends on the underlying field\n    alpha: Field,\n    // The round constants for the\n    round_constants: [Field; N],\n    // The MDS matrix for the Poseidon instance\n    mds: [[Field; T]; T],\n    // An MDS matrix which also applies a basis transformation which allows\n    // sparse matrices to be used for the partial rounds.\n    //\n    // This should be applied instead of `mds` in the final full round.\n    presparse_mds: [[Field; T]; T],\n    // A set of sparse matrices used for MDS mixing for the partial rounds.\n    sparse_mds: [Field; X],\n}\n\npub fn config<let T: u32, let N: u32, let X: u32>(\n    t: Field,\n    rf: u8,\n    rp: u8,\n    alpha: Field,\n    round_constants: [Field; N],\n    mds: [[Field; T]; T],\n    presparse_mds: [[Field; T]; T],\n    sparse_mds: [Field; X],\n) -> PoseidonConfig<T, N, X> {\n    // Input checks\n    assert_eq(rf & 1, 0);\n    assert_eq((t as u8) * rf + rp, N as u8);\n    assert_eq(t, T as Field);\n    assert(alpha != 0);\n\n    PoseidonConfig { t, rf, rp, alpha, round_constants, mds, presparse_mds, sparse_mds }\n}\n\npub fn permute<let T: u32, let N: u32, let X: u32>(\n    pos_conf: PoseidonConfig<T, N, X>,\n    mut state: [Field; T],\n) -> [Field; T] {\n    let PoseidonConfig { t, rf, rp, alpha, round_constants, mds, presparse_mds, sparse_mds } =\n        pos_conf;\n\n    for i in 0..state.len() {\n        state[i] += round_constants[i];\n    }\n\n    for _r in 0..rf / 2 - 1 {\n        state = sigma(state);\n        for i in 0..T {\n            state[i] += round_constants[T * (_r + 1) as u32 + i];\n        }\n        state = apply_matrix(mds, state);\n    }\n\n    state = sigma(state);\n    for i in 0..T {\n        state[i] += round_constants[T * (rf / 2) as u32 + i];\n    }\n    state = apply_matrix(presparse_mds, state);\n\n    for i in 0..T {\n        crate::as_witness(state[i]);\n    }\n\n    for _r in 0..rp {\n        state[0] = state[0].pow_32(alpha);\n        state[0] += round_constants[(rf / 2 + 1) as u32 * T + _r as u32];\n        crate::as_witness(state[0]);\n        {\n            let mut newState0 = 0;\n            for j in 0..T {\n                newState0 += sparse_mds[(T * 2 - 1) * _r as u32 + j as u32] * state[j];\n            }\n            for k in 1..T {\n                state[k] += state[0] * sparse_mds[(t * 2 - 1) as u32 * _r as u32 + T + k - 1];\n            }\n            state[0] = newState0;\n\n            if (_r & 1 == 0) {\n                for k in 1..T {\n                    crate::as_witness(state[k]);\n                }\n            }\n        }\n    }\n\n    for _r in 0..rf / 2 - 1 {\n        state = sigma(state);\n        for i in 0..state.len() {\n            state[i] += round_constants[(rf / 2 + 1) as u32 * T + rp as u32 + (_r as u32) * T + i];\n        }\n        state = apply_matrix(mds, state);\n    }\n\n    state = sigma(state);\n    state = apply_matrix(mds, state);\n\n    state\n}\n\n// Performs matrix multiplication on a vector\nfn apply_matrix<let N: u32>(matrix: [[Field; N]; N], vec: [Field; N]) -> [Field; N] {\n    let mut out = [0; N];\n\n    for i in 0..N {\n        for j in 0..N {\n            out[i] += vec[j] * matrix[j][i];\n        }\n    }\n\n    out\n}\n\n// Corresponding absorption.\nfn absorb<let T: u32, let N: u32, let X: u32, let O: u32>(\n    pos_conf: PoseidonConfig<T, N, X>,\n    // Initial state; usually [0; O]\n    mut state: [Field; T],\n    rate: Field,\n    capacity: Field,\n    msg: [Field; O], // Arbitrary length message\n) -> [Field; T] {\n    assert_eq(pos_conf.t, rate + capacity);\n\n    let mut i = 0;\n\n    for k in 0..msg.len() {\n        // Add current block to state\n        state[capacity + i] += msg[k];\n        i = i + 1;\n        // Enough to absorb\n        if i == rate {\n            state = permute(pos_conf, state);\n            i = 0;\n        }\n    }\n    // If we have one more block to permute\n    if i != 0 {\n        state = permute(pos_conf, state);\n    }\n\n    state\n}\n\nfn sigma<let O: u32>(x: [Field; O]) -> [Field; O] {\n    let mut y = x;\n    for i in 0..O {\n        let t = y[i];\n        let tt = t * t;\n        let tttt = tt * tt;\n        y[i] *= tttt;\n    }\n    y\n}\n\npub struct PoseidonHasher {\n    _state: [Field],\n}\n\nimpl Hasher for PoseidonHasher {\n    #[field(bn254)]\n    fn finish(self) -> Field {\n        let mut result = 0;\n        let len = self._state.len();\n        assert(len < 16);\n        if len == 1 {\n            result = bn254::hash_1([self._state[0]]);\n        }\n        if len == 2 {\n            result = bn254::hash_2([self._state[0], self._state[1]]);\n        }\n        if len == 3 {\n            result = bn254::hash_3([self._state[0], self._state[1], self._state[2]]);\n        }\n        if len == 4 {\n            result = bn254::hash_4([self._state[0], self._state[1], self._state[2], self._state[3]]);\n        }\n        if len == 5 {\n            result = bn254::hash_5([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n            ]);\n        }\n        if len == 6 {\n            result = bn254::hash_6([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n            ]);\n        }\n        if len == 7 {\n            result = bn254::hash_7([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n            ]);\n        }\n        if len == 8 {\n            result = bn254::hash_8([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n            ]);\n        }\n        if len == 9 {\n            result = bn254::hash_9([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n            ]);\n        }\n        if len == 10 {\n            result = bn254::hash_10([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n            ]);\n        }\n        if len == 11 {\n            result = bn254::hash_11([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n            ]);\n        }\n        if len == 12 {\n            result = bn254::hash_12([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n                self._state[11],\n            ]);\n        }\n        if len == 13 {\n            result = bn254::hash_13([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n                self._state[11],\n                self._state[12],\n            ]);\n        }\n        if len == 14 {\n            result = bn254::hash_14([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n                self._state[11],\n                self._state[12],\n                self._state[13],\n            ]);\n        }\n        if len == 15 {\n            result = bn254::hash_15([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n                self._state[11],\n                self._state[12],\n                self._state[13],\n                self._state[14],\n            ]);\n        }\n\n        result\n    }\n\n    #[inline_always]\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for PoseidonHasher {\n    fn default() -> Self {\n        PoseidonHasher { _state: &[] }\n    }\n}\n\nmod poseidon_tests {\n    use crate::hash::poseidon;\n\n    #[test]\n    fn reference_impl_test_vectors() {\n        // hardcoded test vectors from https://extgit.iaik.tugraz.at/krypto/hadeshash/-/blob/master/code/test_vectors.txt\n        {\n            let mut state = [0, 1, 2];\n            let mut expected = [\n                0x115cc0f5e7d690413df64c6b9662e9cf2a3617f2743245519e19607a4417189a,\n                0x0fca49b798923ab0239de1c9e7a4a9a2210312b6a2f616d18b5a87f9b628ae29,\n                0x0e7ae82e40091e63cbd4f16a6d16310b3729d4b6e138fcf54110e2867045a30c,\n            ];\n            assert_eq(\n                expected,\n                poseidon::bn254::perm::x5_3(state),\n                \"Failed to reproduce output for [0, 1, 2]\",\n            );\n        }\n        {\n            let mut state = [0, 1, 2, 3, 4];\n            let mut expected = [\n                0x299c867db6c1fdd79dcefa40e4510b9837e60ebb1ce0663dbaa525df65250465,\n                0x1148aaef609aa338b27dafd89bb98862d8bb2b429aceac47d86206154ffe053d,\n                0x24febb87fed7462e23f6665ff9a0111f4044c38ee1672c1ac6b0637d34f24907,\n                0x0eb08f6d809668a981c186beaf6110060707059576406b248e5d9cf6e78b3d3e,\n                0x07748bc6877c9b82c8b98666ee9d0626ec7f5be4205f79ee8528ef1c4a376fc7,\n            ];\n            assert_eq(\n                expected,\n                poseidon::bn254::perm::x5_5(state),\n                \"Failed to reproduce output for [0, 1, 2, 3, 4]\",\n            );\n        }\n    }\n}\n","path":"std/hash/poseidon/mod.nr"},"68":{"source":"use dep::std::hash::poseidon::bn254;\n// use dep::ecrecover;\n\n\nstruct Person  {\n    age: Field\n}\n\nglobal minAge : u8 = 18;\n\nfn main(fighter: Person, password: [Field;2], passwordHash : pub Field) {\n    assert(fighter.age as u8 > minAge);\n\n    assert(passwordHash == bn254::hash_2(password));\n}\n\n#[test]\nfn test_main() {\n    let p = Person {age : 19};\n    main(p,[1,2], 0x115cc0f5e7d690413df64c6b9662e9cf2a3617f2743245519e19607a4417189a);\n\n    // Uncomment to make test fail\n    // main(1, 1);\n}\n\n#[test(should_fail)]\nfn test_fail(){\n    let p = Person{age:17};\n    main(p, [1,2],0x115cc0f5e7d690413df64c6b9662e9cf2a3617f2743245519e19607a4417189c);\n}","path":"/home/dinar/projects/learning_noir_in_an_afternoon/noirproject/src/main.nr"}},"names":["main"],"brillig_names":["directive_integer_quotient","directive_invert"]}